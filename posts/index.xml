<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on bl7ck0ut</title>
    <link>https://bl7ck0ut.github.io/posts/</link>
    <description>Recent content in Posts on bl7ck0ut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 25 Feb 2026 21:39:50 +0530</lastBuildDate><atom:link href="https://bl7ck0ut.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Payload Placement in the Rich Header &amp; its Execution</title>
      <link>https://bl7ck0ut.github.io/posts/payload-rich-header/</link>
      <pubDate>Wed, 25 Feb 2026 21:39:50 +0530</pubDate>
      
      <guid>https://bl7ck0ut.github.io/posts/payload-rich-header/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In the world of malware development and threat engineering, payload placement is a foundational element of evasion. At its core, payload placement is all about concealing shellcode or malicious configuration data within a host executable, allowing it to remain dormant until it is dynamically extracted and executed at runtime. The primary objective is stealth &amp;amp; slipping past the static signatures and heuristic checks of modern security controls. Historically, malware authors have staged these payloads within the well-documented boundaries of the Portable Executable (PE) format, staging their code in standard sections like &lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, or &lt;code&gt;.rsrc&lt;/code&gt;, or occasionally appending entirely new sections specifically to store the payload.&lt;br&gt;&lt;br&gt;&lt;a href=&#34;https://securelist.com/the-devils-in-the-rich-header/84348/&#34;&gt;Kaspersky&amp;rsquo;s report&lt;/a&gt; on 2018 Olympic Destroyer malware shows that a threat actor deliberately modified and tampered the Rich Header to cause misattribution and complicate forensic analysis. So my question after reading this report was - can it be used for something else?&lt;br&gt;&lt;br&gt;Maybe a place to hide shellcode? &lt;p&gt;In this blog, I will discuss the Rich header, the information it contains, and what it looks like. I will then present my proof of concept (PoC), demonstrating how I used the Rich header as a staging area for shellcode and, during runtime, retrieved the shellcode from the Rich header, loaded it into memory, and executed it. So, letâ€™s begin!&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Unpacking Ursnif/IFSB Sample</title>
      <link>https://bl7ck0ut.github.io/posts/unpacking-ursnif-ifsb-sample/</link>
      <pubDate>Thu, 12 Feb 2026 09:39:50 +0530</pubDate>
      
      <guid>https://bl7ck0ut.github.io/posts/unpacking-ursnif-ifsb-sample/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://attack.mitre.org/software/S0386/&#34;&gt;Ursnif&lt;/a&gt;, also known as Gozi or Dreambot, is a banking trojan that has managed to remain a major threat for nearly two decades. Originally identified back in 2006, it primarily spreads through phishing emails that trick users into clicking malicious links or opening suspicious attachments. Ursnif is associated primarily with data theft, but variants also include components (backdoors, spyware, file injectors, etc.) capable of a wide variety of behaviors.&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
