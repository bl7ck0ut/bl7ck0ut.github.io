<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Malware Development on bl7ck0ut</title>
    <link>https://bl7ck0ut.github.io/tags/malware-development/</link>
    <description>Recent content in Malware Development on bl7ck0ut</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 25 Feb 2026 21:39:50 +0530</lastBuildDate><atom:link href="https://bl7ck0ut.github.io/tags/malware-development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Payload Placement in the Rich Header &amp; its Execution</title>
      <link>https://bl7ck0ut.github.io/posts/payload-rich-header/</link>
      <pubDate>Wed, 25 Feb 2026 21:39:50 +0530</pubDate>
      
      <guid>https://bl7ck0ut.github.io/posts/payload-rich-header/</guid>
      
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;In the world of malware development and threat engineering, payload placement is a foundational element of evasion. At its core, payload placement is all about concealing shellcode or malicious configuration data within a host executable, allowing it to remain dormant until it is dynamically extracted and executed at runtime. The primary objective is stealth &amp;amp; slipping past the static signatures and heuristic checks of modern security controls. Historically, malware authors have staged these payloads within the well-documented boundaries of the Portable Executable (PE) format, staging their code in standard sections like &lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, or &lt;code&gt;.rsrc&lt;/code&gt;, or occasionally appending entirely new sections specifically to store the payload.&lt;br&gt;&lt;br&gt;&lt;a href=&#34;https://securelist.com/the-devils-in-the-rich-header/84348/&#34;&gt;Kaspersky&amp;rsquo;s report&lt;/a&gt; on 2018 Olympic Destroyer malware shows that a threat actor deliberately modified and tampered the Rich Header to cause misattribution and complicate forensic analysis. So my question after reading this report was - can it be used for something else?&lt;br&gt;&lt;br&gt;Maybe a place to hide shellcode? &lt;p&gt;In this blog, I will discuss the Rich header, the information it contains, and what it looks like. I will then present my proof of concept (PoC), demonstrating how I used the Rich header as a staging area for shellcode and, during runtime, retrieved the shellcode from the Rich header, loaded it into memory, and executed it. So, letâ€™s begin!&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>
